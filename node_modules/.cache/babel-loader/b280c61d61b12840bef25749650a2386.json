{"ast":null,"code":"function astar(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode == finishNode) {\n    return false;\n  } // Start by adding our start Node\n  // Calculate initial g,h, and f\n\n\n  startNode.g = 0;\n  startNode.h = startNode.getEuclideanDistanceToNode(endNode);\n  startNode.f = startNode.g + startNode.h; // Push in startNode as first in our list\n\n  nodeList = [];\n  nodeList.push(startNode); // A* algorithm starts here....\n\n  while (nodeList.length > 0) {\n    // Normally we would use a priority queue here to omptimize the\n    // algorithm instead of sorting our list everytime. Javascript doesn't\n    // have anything built in so for simplicity will just use this method for now.\n    // A priority queue would do this for us as we add in our nodes with a min heap.\n    // Sort from greatest to least based on the heuristic function. Sorting backwards,\n    // so we can just use the pop() function on our list to remove the next queued node easily.\n    nodeList.sort((a, b) => a.f < b.f ? 1 : -1); // Check to see if the next node in the list is visited or the end node.\n    // If so remove it, we do not need to check it\n\n    while (nodeList.length > 0 && (nodeList[nodeList.length - 1].visited || nodeList[nodeList.length - 1] == endNode)) {\n      // Check to see if we are finished/at the end node\n      if (nodeList[nodeList.length - 1] == endNode) {\n        break;\n      }\n\n      nodeList.pop();\n    } // Make sure our list is not empty\n\n\n    if (nodeList.length > 0) {\n      currentNode = nodeList[nodeList.length - 1];\n      currentNode.visited = true;\n\n      for (var i = 0; i < currentNode.neighbors.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighbors[i]; // If the node neighbor has not been visited and is not an\n        // obstacle add it to the node list\n\n        if (!nodeNeighbor.visited && !nodeNeighbor.obstacle) nodeList.push(nodeNeighbor); // Calculate possible lower g value\n\n        var possibleLowerG = currentNode.g + currentNode.getEuclideanDistanceToNode(nodeNeighbor); // If lower, update the current g and the parent.\n        // Recalculate the new h\n\n        if (possibleLowerG < nodeNeighbor.g) {\n          nodeNeighbor.parentNode = currentNode;\n          nodeNeighbor.g = possibleLowerG;\n          nodeNeighbor.h = nodeNeighbor.getEuclideanDistanceToNode(endNode); // f(n) = g(n) + h(n)\n\n          nodeNeighbor.f = nodeNeighbor.g + nodeNeighbor.h;\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/algorithms/astar.js"],"names":["astar","grid","startNode","endNode","finishNode","g","h","getEuclideanDistanceToNode","f","nodeList","push","length","sort","a","b","visited","pop","currentNode","i","neighbors","nodeNeighbor","obstacle","possibleLowerG","parentNode"],"mappings":"AAAA,SAASA,KAAT,CAAeC,IAAf,EAAqBC,SAArB,EAAgCC,OAAhC,EAAyC;AACvC;AACA,MAAI,CAACD,SAAD,IAAc,CAACC,OAAf,IAA0BD,SAAS,IAAIE,UAA3C,EAAuD;AACrD,WAAO,KAAP;AACD,GAJsC,CAMvC;AACA;;;AACAF,EAAAA,SAAS,CAACG,CAAV,GAAc,CAAd;AACAH,EAAAA,SAAS,CAACI,CAAV,GAAcJ,SAAS,CAACK,0BAAV,CAAqCJ,OAArC,CAAd;AACAD,EAAAA,SAAS,CAACM,CAAV,GAAcN,SAAS,CAACG,CAAV,GAAcH,SAAS,CAACI,CAAtC,CAVuC,CAYvC;;AACAG,EAAAA,QAAQ,GAAG,EAAX;AACAA,EAAAA,QAAQ,CAACC,IAAT,CAAcR,SAAd,EAduC,CAgBvC;;AACA,SAAOO,QAAQ,CAACE,MAAT,GAAkB,CAAzB,EAA4B;AAC1B;AACA;AACA;AACA;AAEA;AACA;AACAF,IAAAA,QAAQ,CAACG,IAAT,CAAc,CAACC,CAAD,EAAIC,CAAJ,KAAWD,CAAC,CAACL,CAAF,GAAMM,CAAC,CAACN,CAAR,GAAY,CAAZ,GAAgB,CAAC,CAA1C,EAR0B,CAU1B;AACA;;AACA,WACEC,QAAQ,CAACE,MAAT,GAAkB,CAAlB,KACCF,QAAQ,CAACA,QAAQ,CAACE,MAAT,GAAkB,CAAnB,CAAR,CAA8BI,OAA9B,IACCN,QAAQ,CAACA,QAAQ,CAACE,MAAT,GAAkB,CAAnB,CAAR,IAAiCR,OAFnC,CADF,EAIE;AACA;AACA,UAAIM,QAAQ,CAACA,QAAQ,CAACE,MAAT,GAAkB,CAAnB,CAAR,IAAiCR,OAArC,EAA8C;AAC5C;AACD;;AACDM,MAAAA,QAAQ,CAACO,GAAT;AACD,KAtByB,CAwB1B;;;AACA,QAAIP,QAAQ,CAACE,MAAT,GAAkB,CAAtB,EAAyB;AACvBM,MAAAA,WAAW,GAAGR,QAAQ,CAACA,QAAQ,CAACE,MAAT,GAAkB,CAAnB,CAAtB;AACAM,MAAAA,WAAW,CAACF,OAAZ,GAAsB,IAAtB;;AAEA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAAW,CAACE,SAAZ,CAAsBR,MAA1C,EAAkDO,CAAC,EAAnD,EAAuD;AACrD;AACA,YAAIE,YAAY,GAAGH,WAAW,CAACE,SAAZ,CAAsBD,CAAtB,CAAnB,CAFqD,CAIrD;AACA;;AACA,YAAI,CAACE,YAAY,CAACL,OAAd,IAAyB,CAACK,YAAY,CAACC,QAA3C,EACEZ,QAAQ,CAACC,IAAT,CAAcU,YAAd,EAPmD,CASrD;;AACA,YAAIE,cAAc,GAChBL,WAAW,CAACZ,CAAZ,GAAgBY,WAAW,CAACV,0BAAZ,CAAuCa,YAAvC,CADlB,CAVqD,CAarD;AACA;;AACA,YAAIE,cAAc,GAAGF,YAAY,CAACf,CAAlC,EAAqC;AACnCe,UAAAA,YAAY,CAACG,UAAb,GAA0BN,WAA1B;AACAG,UAAAA,YAAY,CAACf,CAAb,GAAiBiB,cAAjB;AACAF,UAAAA,YAAY,CAACd,CAAb,GAAiBc,YAAY,CAACb,0BAAb,CAAwCJ,OAAxC,CAAjB,CAHmC,CAKnC;;AACAiB,UAAAA,YAAY,CAACZ,CAAb,GAAiBY,YAAY,CAACf,CAAb,GAAiBe,YAAY,CAACd,CAA/C;AACD;AACF;AACF,KA5BD,MA4BO;AACL;AACD;AACF;AACF","sourcesContent":["function astar(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode == finishNode) {\n    return false;\n  }\n\n  // Start by adding our start Node\n  // Calculate initial g,h, and f\n  startNode.g = 0;\n  startNode.h = startNode.getEuclideanDistanceToNode(endNode);\n  startNode.f = startNode.g + startNode.h;\n\n  // Push in startNode as first in our list\n  nodeList = [];\n  nodeList.push(startNode);\n\n  // A* algorithm starts here....\n  while (nodeList.length > 0) {\n    // Normally we would use a priority queue here to omptimize the\n    // algorithm instead of sorting our list everytime. Javascript doesn't\n    // have anything built in so for simplicity will just use this method for now.\n    // A priority queue would do this for us as we add in our nodes with a min heap.\n\n    // Sort from greatest to least based on the heuristic function. Sorting backwards,\n    // so we can just use the pop() function on our list to remove the next queued node easily.\n    nodeList.sort((a, b) => (a.f < b.f ? 1 : -1));\n\n    // Check to see if the next node in the list is visited or the end node.\n    // If so remove it, we do not need to check it\n    while (\n      nodeList.length > 0 &&\n      (nodeList[nodeList.length - 1].visited ||\n        nodeList[nodeList.length - 1] == endNode)\n    ) {\n      // Check to see if we are finished/at the end node\n      if (nodeList[nodeList.length - 1] == endNode) {\n        break;\n      }\n      nodeList.pop();\n    }\n\n    // Make sure our list is not empty\n    if (nodeList.length > 0) {\n      currentNode = nodeList[nodeList.length - 1];\n      currentNode.visited = true;\n\n      for (var i = 0; i < currentNode.neighbors.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighbors[i];\n\n        // If the node neighbor has not been visited and is not an\n        // obstacle add it to the node list\n        if (!nodeNeighbor.visited && !nodeNeighbor.obstacle)\n          nodeList.push(nodeNeighbor);\n\n        // Calculate possible lower g value\n        var possibleLowerG =\n          currentNode.g + currentNode.getEuclideanDistanceToNode(nodeNeighbor);\n\n        // If lower, update the current g and the parent.\n        // Recalculate the new h\n        if (possibleLowerG < nodeNeighbor.g) {\n          nodeNeighbor.parentNode = currentNode;\n          nodeNeighbor.g = possibleLowerG;\n          nodeNeighbor.h = nodeNeighbor.getEuclideanDistanceToNode(endNode);\n\n          // f(n) = g(n) + h(n)\n          nodeNeighbor.f = nodeNeighbor.g + nodeNeighbor.h;\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}