{"ast":null,"code":"import Heap from \"heap-js\"; // Greedy-Best-first Algorithm\n// Returns list of nodes that have been visited, and\n// each of the nodes' parent node which will be used\n// for creating our final shortest path\n\nexport function greedybestfirst(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  } // Add each nodes' neighbors before\n  // starting\n\n\n  addNeighborNodes(grid); // Create visited array for visualization\n\n  const visitedNodes = []; // Start by adding our start Node\n  // Calculate initial g, h and f\n\n  startNode.g = 0;\n  startNode.h = getEuclideanDistance(startNode, endNode);\n  startNode.f = startNode.h; // Push in startNode as first in our min heap\n\n  const customPriorityComparator = (a, b) => a.f - b.f;\n\n  const nodeHeap = new Heap(customPriorityComparator);\n  nodeHeap.push(startNode); // GBF algorithm starts here....\n\n  while (nodeHeap.length > 0) {\n    // Check to see if the next node in the list is visited or the end node.\n    // If so remove it, we do not need to check it\n    while (nodeHeap.length > 0 && nodeHeap.peek().isVisited) {\n      nodeHeap.pop();\n    } // Make sure our list is not empty\n\n\n    if (nodeHeap.length > 0) {\n      // Mark current node as visited, add to visited array\n      const currentNode = nodeHeap.peek();\n      currentNode.isVisited = true; // push nodes visited into array for rendering\n      // keep start and end nodes out of list\n\n      if (currentNode !== startNode && currentNode !== endNode) visitedNodes.push(currentNode);\n\n      for (var i = 0; i < currentNode.neighborNodes.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighborNodes[i]; // Calculate possible lower g value\n\n        var possibleLowerG = currentNode.g + getEuclideanDistance(currentNode, nodeNeighbor); // If lower, update the current g and the parent.\n        // Recalculate the new h\n\n        if (possibleLowerG < nodeNeighbor.g) {\n          nodeNeighbor.parentNode = currentNode;\n          nodeNeighbor.g = possibleLowerG;\n          nodeNeighbor.h = getEuclideanDistance(nodeNeighbor, endNode); // f(n) = h(n)\n\n          nodeNeighbor.f = nodeNeighbor.h; // If the node neighbor has not been visited and is not an\n          // obstacle add it to the node list\n\n          if (!nodeNeighbor.isVisited && !nodeNeighbor.isObstacle) nodeHeap.push(nodeNeighbor); // If a node neighbor is the end node\n          // we are finished\n\n          if (nodeNeighbor == endNode) return visitedNodes;\n        }\n      }\n    } else {\n      // No solution, show the visited nodes\n      return visitedNodes;\n    }\n  }\n} // Euclidean hueristic function\n\nconst getEuclideanDistance = (nodeA, nodeB) => {\n  return Math.sqrt((nodeA.col - nodeB.col) * (nodeA.col - nodeB.col) + (nodeA.row - nodeB.row) * (nodeA.row - nodeB.row));\n};\n\nconst addNeighborNodes = grid => {\n  // Adds each neighbor node in the grid.\n  // Have to make sure we do not run out of bounds\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (i < grid.length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j]);\n      }\n\n      if (i > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j]);\n      }\n\n      if (j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i][j + 1]);\n      }\n\n      if (j > 0) {\n        grid[i][j].neighborNodes.push(grid[i][j - 1]);\n      }\n\n      if (i > 0 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j - 1]);\n      }\n\n      if (i < grid.length - 1 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j - 1]);\n      }\n\n      if (i > 0 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j + 1]);\n      }\n\n      if (i < grid.length - 1 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j + 1]);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/algorithms/GreedyBestFirst.js"],"names":["Heap","greedybestfirst","grid","startNode","endNode","addNeighborNodes","visitedNodes","g","h","getEuclideanDistance","f","customPriorityComparator","a","b","nodeHeap","push","length","peek","isVisited","pop","currentNode","i","neighborNodes","nodeNeighbor","possibleLowerG","parentNode","isObstacle","nodeA","nodeB","Math","sqrt","col","row","j"],"mappings":"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","sourcesContent":["import Heap from \"heap-js\";\n// Greedy-Best-first Algorithm\n// Returns list of nodes that have been visited, and\n// each of the nodes' parent node which will be used\n// for creating our final shortest path\n\nexport function greedybestfirst(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  // Add each nodes' neighbors before\n  // starting\n  addNeighborNodes(grid);\n\n  // Create visited array for visualization\n  const visitedNodes = [];\n\n  // Start by adding our start Node\n  // Calculate initial g, h and f\n  startNode.g = 0;\n  startNode.h = getEuclideanDistance(startNode, endNode);\n  startNode.f = startNode.h;\n\n  // Push in startNode as first in our min heap\n  const customPriorityComparator = (a, b) => a.f - b.f;\n  const nodeHeap = new Heap(customPriorityComparator);\n  nodeHeap.push(startNode);\n\n  // GBF algorithm starts here....\n  while (nodeHeap.length > 0) {\n    // Check to see if the next node in the list is visited or the end node.\n    // If so remove it, we do not need to check it\n    while (nodeHeap.length > 0 && nodeHeap.peek().isVisited) {\n      nodeHeap.pop();\n    }\n\n    // Make sure our list is not empty\n    if (nodeHeap.length > 0) {\n      // Mark current node as visited, add to visited array\n      const currentNode = nodeHeap.peek();\n      currentNode.isVisited = true;\n\n      // push nodes visited into array for rendering\n      // keep start and end nodes out of list\n      if (currentNode !== startNode && currentNode !== endNode)\n        visitedNodes.push(currentNode);\n\n      for (var i = 0; i < currentNode.neighborNodes.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighborNodes[i];\n\n        // Calculate possible lower g value\n        var possibleLowerG =\n          currentNode.g + getEuclideanDistance(currentNode, nodeNeighbor);\n\n        // If lower, update the current g and the parent.\n        // Recalculate the new h\n        if (possibleLowerG < nodeNeighbor.g) {\n          nodeNeighbor.parentNode = currentNode;\n          nodeNeighbor.g = possibleLowerG;\n          nodeNeighbor.h = getEuclideanDistance(nodeNeighbor, endNode);\n\n          // f(n) = h(n)\n          nodeNeighbor.f = nodeNeighbor.h;\n\n          // If the node neighbor has not been visited and is not an\n          // obstacle add it to the node list\n          if (!nodeNeighbor.isVisited && !nodeNeighbor.isObstacle)\n            nodeHeap.push(nodeNeighbor);\n\n          // If a node neighbor is the end node\n          // we are finished\n          if (nodeNeighbor == endNode) return visitedNodes;\n        }\n      }\n    } else {\n      // No solution, show the visited nodes\n      return visitedNodes;\n    }\n  }\n}\n\n// Euclidean hueristic function\nconst getEuclideanDistance = (nodeA, nodeB) => {\n  return Math.sqrt(\n    (nodeA.col - nodeB.col) * (nodeA.col - nodeB.col) +\n      (nodeA.row - nodeB.row) * (nodeA.row - nodeB.row)\n  );\n};\n\nconst addNeighborNodes = (grid) => {\n  // Adds each neighbor node in the grid.\n  // Have to make sure we do not run out of bounds\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (i < grid.length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j]);\n      }\n      if (i > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j]);\n      }\n      if (j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i][j + 1]);\n      }\n      if (j > 0) {\n        grid[i][j].neighborNodes.push(grid[i][j - 1]);\n      }\n      if (i > 0 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j - 1]);\n      }\n      if (i < grid.length - 1 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j - 1]);\n      }\n      if (i > 0 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j + 1]);\n      }\n      if (i < grid.length - 1 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j + 1]);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}