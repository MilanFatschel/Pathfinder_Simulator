{"ast":null,"code":"import Queue from \"../structures/queue\"; // BFS Algorithm\n// Returns list of nodes that have been visited, and\n// each of the nodes' parent node which will be used\n// for creating our final shortest path\n\nexport function bfs(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  } // Add each nodes' neighbors before\n  // starting\n\n\n  addNeighborNodes(grid); // Create visited array for visualization\n\n  const visitedNodes = []; // Create a new queue to keep track of BFS\n\n  var nodeQueue = new Queue();\n  nodeQueue.push(startNode); // BFS algorithm starts here....\n\n  while (!nodeQueue.isEmpty()) {\n    // Check to see if the next node in the queue is visited or the end node.\n    // If so remove it, we do not need to check it\n    while (!nodeQueue.isEmpty() && (nodeQueue.front().isVisited || nodeQueue.front() === endNode)) {\n      // Check to see if we ae at the end node\n      if (nodeNeighbor == endNode) return visitedNodes;\n      nodeQueue.pop();\n    } // Make sure our queue is not empty\n\n\n    if (!nodeQueue.isEmpty()) {\n      // Mark current node as visited, add to visited array\n      const currentNode = nodeQueue.front();\n      currentNode.isVisited = true; // push nodes visited into list for rendering\n      // keep start and end nodes out of list\n\n      if (currentNode !== startNode && currentNode !== endNode) visitedNodes.push(currentNode);\n      console.log(currentNode);\n\n      for (var i = 0; i < currentNode.neighborNodes.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighborNodes[i]; // If the node neighbor has not been visited and is not an\n        // obstacle, add the current node as a parent\n        // and  add it to the node list\n\n        if (!nodeNeighbor.isVisited && !nodeNeighbor.isObstacle) {\n          // Only update the parent if is has no parent yet, since\n          // BFS works in levels we do not want to update\n          if (!nodeNeighbor.parentNode) nodeNeighbor.parentNode = currentNode;\n          nodeQueue.push(nodeNeighbor);\n        }\n      }\n    } else {\n      // Our queue is empty and we are still trying find a path...\n      // Either there is no solution or something has gone wrong\n      return [];\n    }\n  }\n}\n\nconst addNeighborNodes = grid => {\n  // Adds each neighbor node in the grid.\n  // Have to make sure we do not run out of bounds\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (i < grid.length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j]);\n      }\n\n      if (i > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j]);\n      }\n\n      if (j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i][j + 1]);\n      }\n\n      if (j > 0) {\n        grid[i][j].neighborNodes.push(grid[i][j - 1]);\n      }\n\n      if (i > 0 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j - 1]);\n      }\n\n      if (i < grid.length - 1 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j - 1]);\n      }\n\n      if (i > 0 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j + 1]);\n      }\n\n      if (i < grid.length - 1 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j + 1]);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/algorithms/bfs.js"],"names":["Queue","bfs","grid","startNode","endNode","addNeighborNodes","visitedNodes","nodeQueue","push","isEmpty","front","isVisited","nodeNeighbor","pop","currentNode","console","log","i","neighborNodes","length","isObstacle","parentNode","j"],"mappings":"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","sourcesContent":["import Queue from \"../structures/queue\";\n\n// BFS Algorithm\n// Returns list of nodes that have been visited, and\n// each of the nodes' parent node which will be used\n// for creating our final shortest path\n\nexport function bfs(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  // Add each nodes' neighbors before\n  // starting\n  addNeighborNodes(grid);\n\n  // Create visited array for visualization\n  const visitedNodes = [];\n\n  // Create a new queue to keep track of BFS\n  var nodeQueue = new Queue();\n  nodeQueue.push(startNode);\n\n  // BFS algorithm starts here....\n  while (!nodeQueue.isEmpty()) {\n    // Check to see if the next node in the queue is visited or the end node.\n    // If so remove it, we do not need to check it\n    while (\n      !nodeQueue.isEmpty() &&\n      (nodeQueue.front().isVisited || nodeQueue.front() === endNode)\n    ) {\n      // Check to see if we ae at the end node\n      if (nodeNeighbor == endNode) return visitedNodes;\n      nodeQueue.pop();\n    }\n\n    // Make sure our queue is not empty\n    if (!nodeQueue.isEmpty()) {\n      // Mark current node as visited, add to visited array\n      const currentNode = nodeQueue.front();\n      currentNode.isVisited = true;\n\n      // push nodes visited into list for rendering\n      // keep start and end nodes out of list\n      if (currentNode !== startNode && currentNode !== endNode)\n        visitedNodes.push(currentNode);\n\n      console.log(currentNode);\n\n      for (var i = 0; i < currentNode.neighborNodes.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighborNodes[i];\n\n        // If the node neighbor has not been visited and is not an\n        // obstacle, add the current node as a parent\n        // and  add it to the node list\n        if (!nodeNeighbor.isVisited && !nodeNeighbor.isObstacle) {\n          // Only update the parent if is has no parent yet, since\n          // BFS works in levels we do not want to update\n          if (!nodeNeighbor.parentNode) nodeNeighbor.parentNode = currentNode;\n          nodeQueue.push(nodeNeighbor);\n        }\n      }\n    } else {\n      // Our queue is empty and we are still trying find a path...\n      // Either there is no solution or something has gone wrong\n      return [];\n    }\n  }\n}\n\nconst addNeighborNodes = (grid) => {\n  // Adds each neighbor node in the grid.\n  // Have to make sure we do not run out of bounds\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (i < grid.length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j]);\n      }\n      if (i > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j]);\n      }\n      if (j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i][j + 1]);\n      }\n      if (j > 0) {\n        grid[i][j].neighborNodes.push(grid[i][j - 1]);\n      }\n      if (i > 0 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j - 1]);\n      }\n      if (i < grid.length - 1 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j - 1]);\n      }\n      if (i > 0 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j + 1]);\n      }\n      if (i < grid.length - 1 && j < grid[i].length - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j + 1]);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}