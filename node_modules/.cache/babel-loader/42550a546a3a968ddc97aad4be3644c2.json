{"ast":null,"code":"class Node {\n  constructor(val, priority) {\n    this.value = val;\n    this.priority = priority;\n    this.next = null;\n  }\n\n}\n\nexport default class PriorityQueue {\n  constructor() {\n    this.heap = [null];\n  }\n\n  insert(value, priority) {\n    const newNode = new Node(value, priority);\n    this.heap.push(newNode);\n    let currentNodeIdx = this.heap.length - 1;\n    let currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\n\n    while (this.heap[currentNodeParentIdx] && newNode.priority > this.heap[currentNodeParentIdx].priority) {\n      const parent = this.heap[currentNodeParentIdx];\n      this.heap[currentNodeParentIdx] = newNode;\n      this.heap[currentNodeIdx] = parent;\n      currentNodeIdx = currentNodeParentIdx;\n      currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\n    }\n  }\n\n  getMin() {\n    /* Accessing the min element at index 1 in the heap array */\n    return this.heap[this.heap.length - 1];\n  }\n\n  getLength() {\n    return this.heap.length;\n  }\n\n  remove() {\n    if (this.heap.length < 3) {\n      const toReturn = this.heap.pop();\n      this.heap[1] = null;\n      return toReturn;\n    }\n\n    const toRemove = this.heap[1];\n    this.heap[1] = this.heap.pop();\n    let currentIdx = 1;\n    let [left, right] = [2 * currentIdx, 2 * currentIdx + 1];\n    let currentChildIdx = this.heap[right] && this.heap[right].priority >= this.heap[left].priority ? right : left;\n\n    while (this.heap[currentChildIdx] && this.heap[currentIdx].priority <= this.heap[currentChildIdx].priority) {\n      let currentNode = this.heap[currentIdx];\n      let currentChildNode = this.heap[currentChildIdx];\n      this.heap[currentChildIdx] = currentNode;\n      this.heap[currentIdx] = currentChildNode;\n    }\n\n    return toRemove;\n  }\n\n}","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/structures/priority_queue.js"],"names":["Node","constructor","val","priority","value","next","PriorityQueue","heap","insert","newNode","push","currentNodeIdx","length","currentNodeParentIdx","Math","floor","parent","getMin","getLength","remove","toReturn","pop","toRemove","currentIdx","left","right","currentChildIdx","currentNode","currentChildNode"],"mappings":"AAAA,MAAMA,IAAN,CAAW;AACTC,EAAAA,WAAW,CAACC,GAAD,EAAMC,QAAN,EAAgB;AACzB,SAAKC,KAAL,GAAaF,GAAb;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKE,IAAL,GAAY,IAAZ;AACD;;AALQ;;AAQX,eAAe,MAAMC,aAAN,CAAoB;AACjCL,EAAAA,WAAW,GAAG;AACZ,SAAKM,IAAL,GAAY,CAAC,IAAD,CAAZ;AACD;;AAEDC,EAAAA,MAAM,CAACJ,KAAD,EAAQD,QAAR,EAAkB;AACtB,UAAMM,OAAO,GAAG,IAAIT,IAAJ,CAASI,KAAT,EAAgBD,QAAhB,CAAhB;AACA,SAAKI,IAAL,CAAUG,IAAV,CAAeD,OAAf;AACA,QAAIE,cAAc,GAAG,KAAKJ,IAAL,CAAUK,MAAV,GAAmB,CAAxC;AACA,QAAIC,oBAAoB,GAAGC,IAAI,CAACC,KAAL,CAAWJ,cAAc,GAAG,CAA5B,CAA3B;;AACA,WACE,KAAKJ,IAAL,CAAUM,oBAAV,KACAJ,OAAO,CAACN,QAAR,GAAmB,KAAKI,IAAL,CAAUM,oBAAV,EAAgCV,QAFrD,EAGE;AACA,YAAMa,MAAM,GAAG,KAAKT,IAAL,CAAUM,oBAAV,CAAf;AACA,WAAKN,IAAL,CAAUM,oBAAV,IAAkCJ,OAAlC;AACA,WAAKF,IAAL,CAAUI,cAAV,IAA4BK,MAA5B;AACAL,MAAAA,cAAc,GAAGE,oBAAjB;AACAA,MAAAA,oBAAoB,GAAGC,IAAI,CAACC,KAAL,CAAWJ,cAAc,GAAG,CAA5B,CAAvB;AACD;AACF;;AAEDM,EAAAA,MAAM,GAAG;AACP;AACA,WAAO,KAAKV,IAAL,CAAU,KAAKA,IAAL,CAAUK,MAAV,GAAmB,CAA7B,CAAP;AACD;;AAEDM,EAAAA,SAAS,GAAG;AACV,WAAO,KAAKX,IAAL,CAAUK,MAAjB;AACD;;AAEDO,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKZ,IAAL,CAAUK,MAAV,GAAmB,CAAvB,EAA0B;AACxB,YAAMQ,QAAQ,GAAG,KAAKb,IAAL,CAAUc,GAAV,EAAjB;AACA,WAAKd,IAAL,CAAU,CAAV,IAAe,IAAf;AACA,aAAOa,QAAP;AACD;;AACD,UAAME,QAAQ,GAAG,KAAKf,IAAL,CAAU,CAAV,CAAjB;AACA,SAAKA,IAAL,CAAU,CAAV,IAAe,KAAKA,IAAL,CAAUc,GAAV,EAAf;AACA,QAAIE,UAAU,GAAG,CAAjB;AACA,QAAI,CAACC,IAAD,EAAOC,KAAP,IAAgB,CAAC,IAAIF,UAAL,EAAiB,IAAIA,UAAJ,GAAiB,CAAlC,CAApB;AACA,QAAIG,eAAe,GACjB,KAAKnB,IAAL,CAAUkB,KAAV,KAAoB,KAAKlB,IAAL,CAAUkB,KAAV,EAAiBtB,QAAjB,IAA6B,KAAKI,IAAL,CAAUiB,IAAV,EAAgBrB,QAAjE,GACIsB,KADJ,GAEID,IAHN;;AAIA,WACE,KAAKjB,IAAL,CAAUmB,eAAV,KACA,KAAKnB,IAAL,CAAUgB,UAAV,EAAsBpB,QAAtB,IAAkC,KAAKI,IAAL,CAAUmB,eAAV,EAA2BvB,QAF/D,EAGE;AACA,UAAIwB,WAAW,GAAG,KAAKpB,IAAL,CAAUgB,UAAV,CAAlB;AACA,UAAIK,gBAAgB,GAAG,KAAKrB,IAAL,CAAUmB,eAAV,CAAvB;AACA,WAAKnB,IAAL,CAAUmB,eAAV,IAA6BC,WAA7B;AACA,WAAKpB,IAAL,CAAUgB,UAAV,IAAwBK,gBAAxB;AACD;;AACD,WAAON,QAAP;AACD;;AAvDgC","sourcesContent":["class Node {\n  constructor(val, priority) {\n    this.value = val;\n    this.priority = priority;\n    this.next = null;\n  }\n}\n\nexport default class PriorityQueue {\n  constructor() {\n    this.heap = [null];\n  }\n\n  insert(value, priority) {\n    const newNode = new Node(value, priority);\n    this.heap.push(newNode);\n    let currentNodeIdx = this.heap.length - 1;\n    let currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\n    while (\n      this.heap[currentNodeParentIdx] &&\n      newNode.priority > this.heap[currentNodeParentIdx].priority\n    ) {\n      const parent = this.heap[currentNodeParentIdx];\n      this.heap[currentNodeParentIdx] = newNode;\n      this.heap[currentNodeIdx] = parent;\n      currentNodeIdx = currentNodeParentIdx;\n      currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\n    }\n  }\n\n  getMin() {\n    /* Accessing the min element at index 1 in the heap array */\n    return this.heap[this.heap.length - 1];\n  }\n\n  getLength() {\n    return this.heap.length;\n  }\n\n  remove() {\n    if (this.heap.length < 3) {\n      const toReturn = this.heap.pop();\n      this.heap[1] = null;\n      return toReturn;\n    }\n    const toRemove = this.heap[1];\n    this.heap[1] = this.heap.pop();\n    let currentIdx = 1;\n    let [left, right] = [2 * currentIdx, 2 * currentIdx + 1];\n    let currentChildIdx =\n      this.heap[right] && this.heap[right].priority >= this.heap[left].priority\n        ? right\n        : left;\n    while (\n      this.heap[currentChildIdx] &&\n      this.heap[currentIdx].priority <= this.heap[currentChildIdx].priority\n    ) {\n      let currentNode = this.heap[currentIdx];\n      let currentChildNode = this.heap[currentChildIdx];\n      this.heap[currentChildIdx] = currentNode;\n      this.heap[currentIdx] = currentChildNode;\n    }\n    return toRemove;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}