{"ast":null,"code":"// A* Algorithm\n// Returns list of nodes that have been visited, and\n// each of the nodes' parent node which will be used\n// for creating our final shortest path\nexport function astar(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  } // Add each nodes' neighbors before\n  // starting\n\n\n  addNeighborNodes(grid); // Create visited array for visualization\n\n  const visitedNodes = []; // Start by adding our start Node\n  // Calculate initial g,h, and f\n\n  startNode.g = 0;\n  startNode.h = getEuclideanDistance(startNode, endNode);\n  startNode.f = startNode.g + startNode.h; // Push in startNode as first in our list\n\n  const nodeList = [];\n  nodeList.push(startNode); // A* algorithm starts here....\n\n  while (nodeList.length > 0) {\n    // Normally we would use a priority queue here to omptimize the\n    // algorithm instead of sorting our list everytime. Javascript doesn't\n    // have anything built in so for simplicity will just use this method for now.\n    // A priority queue would do this for us as we add in our nodes with a min heap.\n    // Sort from greatest to least based on the heuristic function. Sorting backwards,\n    // so we can just use the pop() function on our list to remove the next queued node easily.\n    nodeList.sort((a, b) => a.f < b.f ? 1 : -1); // Check to see if the next node in the list is visited or the end node.\n    // If so remove it, we do not need to check it\n\n    while (nodeList.length > 0 && (nodeList[nodeList.length - 1].isVisited || nodeList[nodeList.length - 1].isObstacle || nodeList[nodeList.length - 1] === endNode)) {\n      // Check to see if we are finished/at the end node\n      if (nodeList[nodeList.length - 1] === endNode) {\n        return visitedNodes;\n      }\n\n      nodeList.pop();\n    } // Make sure our list is not empty\n\n\n    if (nodeList.length > 0) {\n      // Mark current node as visited, add to visited array\n      const currentNode = nodeList[nodeList.length - 1];\n      currentNode.isVisited = true;\n      console.log(currentNode);\n      visitedNodes.push(currentNode);\n\n      for (var i = 0; i < currentNode.neighborNodes.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighborNodes[i]; // If the node neighbor has not been visited and is not an\n        // obstacle add it to the node list\n\n        if (!nodeNeighbor.isVisited && !nodeNeighbor.isObstacle) nodeList.push(nodeNeighbor); // Calculate possible lower g value\n\n        var possibleLowerG = currentNode.g + getEuclideanDistance(currentNode, nodeNeighbor); // If lower, update the current g and the parent.\n        // Recalculate the new h\n\n        if (possibleLowerG < nodeNeighbor.g) {\n          nodeNeighbor.parentNode = currentNode;\n          nodeNeighbor.g = possibleLowerG;\n          nodeNeighbor.h = getEuclideanDistance(nodeNeighbor, endNode); // f(n) = g(n) + h(n)\n\n          nodeNeighbor.f = nodeNeighbor.g + nodeNeighbor.h;\n        }\n      }\n    } else {\n      break;\n    }\n  }\n} // Euclidean hueristic function\n\nconst getEuclideanDistance = (nodeA, nodeB) => {\n  return Math.sqrt((nodeA.col - nodeB.col) * (nodeA.col - nodeB.col) + (nodeA.row - nodeB.row) * (nodeA.row - nodeB.row));\n};\n\nconst addNeighborNodes = grid => {\n  // Adds each neighbor node in the grid.\n  // Have to make sure we do not run out of bounds\n  for (let i = 0; i < GRID_COL_LENGTH; i++) {\n    for (let j = 0; j < GRID_ROW_LENGTH; j++) {\n      if (i < GRID_COL_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j]);\n      }\n\n      if (i > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j]);\n      }\n\n      if (j < GRID_ROW_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i][j + 1]);\n      }\n\n      if (j > 0) {\n        grid[i][j].neighborNodes.push(grid[i][j - 1]);\n      }\n\n      if (i > 0 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j - 1]);\n      }\n\n      if (i < GRID_COL_LENGTH - 1 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j - 1]);\n      }\n\n      if (i > 0 && j < GRID_ROW_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j + 1]);\n      }\n\n      if (i < GRID_COL_LENGTH - 1 && j < GRID_ROW_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j + 1]);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/algorithms/astar.js"],"names":["astar","grid","startNode","endNode","addNeighborNodes","visitedNodes","g","h","getEuclideanDistance","f","nodeList","push","length","sort","a","b","isVisited","isObstacle","pop","currentNode","console","log","i","neighborNodes","nodeNeighbor","possibleLowerG","parentNode","nodeA","nodeB","Math","sqrt","col","row","GRID_COL_LENGTH","j","GRID_ROW_LENGTH"],"mappings":"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","sourcesContent":["// A* Algorithm\n// Returns list of nodes that have been visited, and\n// each of the nodes' parent node which will be used\n// for creating our final shortest path\n\nexport function astar(grid, startNode, endNode) {\n  // Inital check on our parameters\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  // Add each nodes' neighbors before\n  // starting\n  addNeighborNodes(grid);\n\n  // Create visited array for visualization\n  const visitedNodes = [];\n\n  // Start by adding our start Node\n  // Calculate initial g,h, and f\n  startNode.g = 0;\n  startNode.h = getEuclideanDistance(startNode, endNode);\n  startNode.f = startNode.g + startNode.h;\n\n  // Push in startNode as first in our list\n  const nodeList = [];\n  nodeList.push(startNode);\n\n  // A* algorithm starts here....\n  while (nodeList.length > 0) {\n    // Normally we would use a priority queue here to omptimize the\n    // algorithm instead of sorting our list everytime. Javascript doesn't\n    // have anything built in so for simplicity will just use this method for now.\n    // A priority queue would do this for us as we add in our nodes with a min heap.\n\n    // Sort from greatest to least based on the heuristic function. Sorting backwards,\n    // so we can just use the pop() function on our list to remove the next queued node easily.\n    nodeList.sort((a, b) => (a.f < b.f ? 1 : -1));\n\n    // Check to see if the next node in the list is visited or the end node.\n    // If so remove it, we do not need to check it\n    while (\n      nodeList.length > 0 &&\n      (nodeList[nodeList.length - 1].isVisited ||\n        nodeList[nodeList.length - 1].isObstacle ||\n        nodeList[nodeList.length - 1] === endNode)\n    ) {\n      // Check to see if we are finished/at the end node\n      if (nodeList[nodeList.length - 1] === endNode) {\n        return visitedNodes;\n      }\n      nodeList.pop();\n    }\n\n    // Make sure our list is not empty\n    if (nodeList.length > 0) {\n      // Mark current node as visited, add to visited array\n      const currentNode = nodeList[nodeList.length - 1];\n      currentNode.isVisited = true;\n      console.log(currentNode);\n      visitedNodes.push(currentNode);\n\n      for (var i = 0; i < currentNode.neighborNodes.length; i++) {\n        // Get current neighbor being scanned\n        var nodeNeighbor = currentNode.neighborNodes[i];\n\n        // If the node neighbor has not been visited and is not an\n        // obstacle add it to the node list\n        if (!nodeNeighbor.isVisited && !nodeNeighbor.isObstacle)\n          nodeList.push(nodeNeighbor);\n\n        // Calculate possible lower g value\n        var possibleLowerG =\n          currentNode.g + getEuclideanDistance(currentNode, nodeNeighbor);\n\n        // If lower, update the current g and the parent.\n        // Recalculate the new h\n        if (possibleLowerG < nodeNeighbor.g) {\n          nodeNeighbor.parentNode = currentNode;\n          nodeNeighbor.g = possibleLowerG;\n          nodeNeighbor.h = getEuclideanDistance(nodeNeighbor, endNode);\n\n          // f(n) = g(n) + h(n)\n          nodeNeighbor.f = nodeNeighbor.g + nodeNeighbor.h;\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}\n\n// Euclidean hueristic function\nconst getEuclideanDistance = (nodeA, nodeB) => {\n  return Math.sqrt(\n    (nodeA.col - nodeB.col) * (nodeA.col - nodeB.col) +\n      (nodeA.row - nodeB.row) * (nodeA.row - nodeB.row)\n  );\n};\n\nconst addNeighborNodes = (grid) => {\n  // Adds each neighbor node in the grid.\n  // Have to make sure we do not run out of bounds\n\n  for (let i = 0; i < GRID_COL_LENGTH; i++) {\n    for (let j = 0; j < GRID_ROW_LENGTH; j++) {\n      if (i < GRID_COL_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j]);\n      }\n      if (i > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j]);\n      }\n      if (j < GRID_ROW_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i][j + 1]);\n      }\n      if (j > 0) {\n        grid[i][j].neighborNodes.push(grid[i][j - 1]);\n      }\n      if (i > 0 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j - 1]);\n      }\n      if (i < GRID_COL_LENGTH - 1 && j > 0) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j - 1]);\n      }\n      if (i > 0 && j < GRID_ROW_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i - 1][j + 1]);\n      }\n      if (i < GRID_COL_LENGTH - 1 && j < GRID_ROW_LENGTH - 1) {\n        grid[i][j].neighborNodes.push(grid[i + 1][j + 1]);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}