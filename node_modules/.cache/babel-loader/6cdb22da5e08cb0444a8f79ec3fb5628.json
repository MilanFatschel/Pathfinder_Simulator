{"ast":null,"code":"var __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n/**\n * Heap\n * @type {Class}\n */\n\n\nvar Heap =\n/** @class */\nfunction () {\n  /**\n   * Heap instance constructor.\n   * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n   */\n  function Heap(compare) {\n    var _this = this;\n\n    if (compare === void 0) {\n      compare = Heap.minComparator;\n    }\n\n    this.compare = compare;\n    this.heapArray = [];\n    this._limit = 0;\n    /**\n     * Alias of add\n     */\n\n    this.offer = this.add;\n    /**\n     * Alias of peek\n     */\n\n    this.element = this.peek;\n    /**\n     * Alias of pop\n     */\n\n    this.poll = this.pop;\n    /**\n     * Returns the inverse to the comparison function.\n     * @return {Function}\n     */\n\n    this._invertedCompare = function (a, b) {\n      return -1 * _this.compare(a, b);\n    };\n  }\n  /*\n            Static methods\n   */\n\n  /**\n   * Gets children indices for given index.\n   * @param  {Number} idx     Parent index\n   * @return {Array(Number)}  Array of children indices\n   */\n\n\n  Heap.getChildrenIndexOf = function (idx) {\n    return [idx * 2 + 1, idx * 2 + 2];\n  };\n  /**\n   * Gets parent index for given index.\n   * @param  {Number} idx  Children index\n   * @return {Number | undefined}      Parent index, -1 if idx is 0\n   */\n\n\n  Heap.getParentIndexOf = function (idx) {\n    if (idx <= 0) {\n      return -1;\n    }\n\n    var whichChildren = idx % 2 ? 1 : 2;\n    return Math.floor((idx - whichChildren) / 2);\n  };\n  /**\n   * Gets sibling index for given index.\n   * @param  {Number} idx  Children index\n   * @return {Number | undefined}      Sibling index, -1 if idx is 0\n   */\n\n\n  Heap.getSiblingIndexOf = function (idx) {\n    if (idx <= 0) {\n      return -1;\n    }\n\n    var whichChildren = idx % 2 ? 1 : -1;\n    return idx + whichChildren;\n  };\n  /**\n   * Min heap comparison function, default.\n   * @param  {any} a     First element\n   * @param  {any} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n\n\n  Heap.minComparator = function (a, b) {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * Max heap comparison function.\n   * @param  {any} a     First element\n   * @param  {any} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n\n\n  Heap.maxComparator = function (a, b) {\n    if (b > a) {\n      return 1;\n    } else if (b < a) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * Min number heap comparison function, default.\n   * @param  {Number} a     First element\n   * @param  {Number} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n\n\n  Heap.minComparatorNumber = function (a, b) {\n    return a - b;\n  };\n  /**\n   * Max number heap comparison function.\n   * @param  {Number} a     First element\n   * @param  {Number} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n\n\n  Heap.maxComparatorNumber = function (a, b) {\n    return b - a;\n  };\n  /**\n   * Default equality function.\n   * @param  {any} a    First element\n   * @param  {any} b    Second element\n   * @return {Boolean}  True if equal, false otherwise\n   */\n\n\n  Heap.defaultIsEqual = function (a, b) {\n    return a === b;\n  };\n  /**\n   * Prints a heap.\n   * @param  {Heap} heap Heap to be printed\n   * @returns {String}\n   */\n\n\n  Heap.print = function (heap) {\n    function deep(i) {\n      var pi = Heap.getParentIndexOf(i);\n      return Math.floor(Math.log2(pi + 1));\n    }\n\n    function repeat(str, times) {\n      var out = '';\n\n      for (; times > 0; --times) {\n        out += str;\n      }\n\n      return out;\n    }\n\n    var node = 0;\n    var lines = [];\n    var maxLines = deep(heap.length - 1) + 2;\n    var maxLength = 0;\n\n    while (node < heap.length) {\n      var i = deep(node) + 1;\n\n      if (node === 0) {\n        i = 0;\n      } // Text representation\n\n\n      var nodeText = String(heap.get(node));\n\n      if (nodeText.length > maxLength) {\n        maxLength = nodeText.length;\n      } // Add to line\n\n\n      lines[i] = lines[i] || [];\n      lines[i].push(nodeText);\n      node += 1;\n    }\n\n    return lines.map(function (line, i) {\n      var times = Math.pow(2, maxLines - i) - 1;\n      return repeat(' ', Math.floor(times / 2) * maxLength) + line.map(function (el) {\n        // centered\n        var half = (maxLength - el.length) / 2;\n        return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n      }).join(repeat(' ', times * maxLength));\n    }).join('\\n');\n  };\n  /*\n            Python style\n   */\n\n  /**\n   * Converts an array into an array-heap\n   * @param  {Array}    arr      Array to be modified\n   * @param  {Function} compare  Optional compare function\n   * @return {Heap}              For convenience, it returns a Heap instance\n   */\n\n\n  Heap.heapify = function (arr, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = arr;\n    heap.init();\n    return heap;\n  };\n  /**\n   * Extract the peek of an array-heap\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n\n\n  Heap.heappop = function (heapArr, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.pop();\n  };\n  /**\n   * Pushes a item into an array-heap\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item to push\n   * @param  {Function} compare  Optional compare function\n   */\n\n\n  Heap.heappush = function (heapArr, item, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    heap.push(item);\n  };\n  /**\n   * Push followed by pop, faster\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item to push\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n\n\n  Heap.heappushpop = function (heapArr, item, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.pushpop(item);\n  };\n  /**\n   * Replace peek with item\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item as replacement\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n\n\n  Heap.heapreplace = function (heapArr, item, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.replace(item);\n  };\n  /**\n   * Return the `n` most valuable elements\n   * @param  {Array}    heapArr  Array, should be a heap\n   * @param  {number}   n        Max number of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n\n\n  Heap.heaptop = function (heapArr, n, compare) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.top(n);\n  };\n  /**\n   * Return the `n` least valuable elements\n   * @param  {Array}    heapArr  Array, should be a heap\n   * @param  {number}   n        Max number of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n\n\n  Heap.heapbottom = function (heapArr, n, compare) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.bottom(n);\n  };\n  /*\n            Instance methods\n   */\n\n  /**\n   * Adds an element to the heap. Aliases: `offer`.\n   * Same as: push(element)\n   * @param {any} element Element to be added\n   * @return {Boolean} true\n   */\n\n\n  Heap.prototype.add = function (element) {\n    this._sortNodeUp(this.heapArray.push(element) - 1);\n\n    this._applyLimit();\n\n    return true;\n  };\n  /**\n   * Adds an array of elements to the heap.\n   * Similar as: push(element, element, ...).\n   * @param {Array} elements Elements to be added\n   * @return {Boolean} true\n   */\n\n\n  Heap.prototype.addAll = function (elements) {\n    var _a;\n\n    var i = this.length;\n\n    (_a = this.heapArray).push.apply(_a, elements);\n\n    for (var l = this.length; i < l; ++i) {\n      this._sortNodeUp(i);\n    }\n\n    this._applyLimit();\n\n    return true;\n  };\n  /**\n   * Return the bottom (lowest value) N elements of the heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n\n\n  Heap.prototype.bottom = function (n) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    if (this.heapArray.length === 0 || n <= 0) {\n      // Nothing to do\n      return [];\n    } else if (this.heapArray.length === 1) {\n      // Just the peek\n      return [this.heapArray[0]];\n    } else if (n >= this.heapArray.length) {\n      // The whole heap\n      return this.heapArray.slice(0);\n    } else {\n      // Some elements\n      var result = this._bottomN_push(n);\n\n      return result;\n    }\n  };\n  /**\n   * Check if the heap is sorted, useful for testing purposes.\n   * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n   */\n\n\n  Heap.prototype.check = function () {\n    var _this = this;\n\n    return this.heapArray.find(function (el, j, arr) {\n      return !!_this.getChildrenOf(j).find(function (ch) {\n        return _this.compare(el, ch) > 0;\n      });\n    });\n  };\n  /**\n   * Remove all of the elements from this heap.\n   */\n\n\n  Heap.prototype.clear = function () {\n    this.heapArray = [];\n  };\n  /**\n   * Clone this heap\n   * @return {Heap}\n   */\n\n\n  Heap.prototype.clone = function () {\n    var cloned = new Heap(this.comparator());\n    cloned.heapArray = this.toArray();\n    cloned._limit = this._limit;\n    return cloned;\n  };\n  /**\n   * Returns the comparison function.\n   * @return {Function}\n   */\n\n\n  Heap.prototype.comparator = function () {\n    return this.compare;\n  };\n  /**\n   * Returns true if this queue contains the specified element.\n   * @param  {any}      o   Element to be found\n   * @param  {Function} fn  Optional comparison function, receives (element, needle)\n   * @return {Boolean}\n   */\n\n\n  Heap.prototype.contains = function (o, fn) {\n    if (fn === void 0) {\n      fn = Heap.defaultIsEqual;\n    }\n\n    return this.heapArray.findIndex(function (el) {\n      return fn(el, o);\n    }) >= 0;\n  };\n  /**\n   * Initialise a heap, sorting nodes\n   * @param  {Array} array Optional initial state array\n   */\n\n\n  Heap.prototype.init = function (array) {\n    if (array) {\n      this.heapArray = array.slice(0);\n    }\n\n    for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n      this._sortNodeDown(i);\n    }\n\n    this._applyLimit();\n  };\n  /**\n   * Test if the heap has no elements.\n   * @return {Boolean} True if no elements on the heap\n   */\n\n\n  Heap.prototype.isEmpty = function () {\n    return this.length === 0;\n  };\n  /**\n   * Get the leafs of the tree (no children nodes)\n   */\n\n\n  Heap.prototype.leafs = function () {\n    if (this.heapArray.length === 0) {\n      return [];\n    }\n\n    var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n    return this.heapArray.slice(pi + 1);\n  };\n\n  Object.defineProperty(Heap.prototype, \"length\", {\n    /**\n     * Length of the heap.\n     * @return {Number}\n     */\n    get: function () {\n      return this.heapArray.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Heap.prototype, \"limit\", {\n    /**\n     * Get length limit of the heap.\n     * @return {Number}\n     */\n    get: function () {\n      return this._limit;\n    },\n\n    /**\n     * Set length limit of the heap.\n     * @return {Number}\n     */\n    set: function (_l) {\n      this._limit = _l;\n\n      this._applyLimit();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Top node. Aliases: `element`.\n   * Same as: `top(1)[0]`\n   * @return {any} Top node\n   */\n\n  Heap.prototype.peek = function () {\n    return this.heapArray[0];\n  };\n  /**\n   * Extract the top node (root). Aliases: `poll`.\n   * @return {any} Extracted top node, undefined if empty\n   */\n\n\n  Heap.prototype.pop = function () {\n    var last = this.heapArray.pop();\n\n    if (this.length > 0 && last !== undefined) {\n      return this.replace(last);\n    }\n\n    return last;\n  };\n  /**\n   * Pushes element(s) to the heap.\n   * @param  {...any} elements Elements to insert\n   * @return {Boolean} True if elements are present\n   */\n\n\n  Heap.prototype.push = function () {\n    var elements = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      elements[_i] = arguments[_i];\n    }\n\n    if (elements.length < 1) {\n      return false;\n    } else if (elements.length === 1) {\n      return this.add(elements[0]);\n    } else {\n      return this.addAll(elements);\n    }\n  };\n  /**\n   * Same as push & pop in sequence, but faster\n   * @param  {any} element Element to insert\n   * @return {any}  Extracted top node\n   */\n\n\n  Heap.prototype.pushpop = function (element) {\n    var _a;\n\n    if (this.compare(this.heapArray[0], element) < 0) {\n      _a = [this.heapArray[0], element], element = _a[0], this.heapArray[0] = _a[1];\n\n      this._sortNodeDown(0);\n    }\n\n    return element;\n  };\n  /**\n   * Remove an element from the heap.\n   * @param  {any}   o      Element to be found\n   * @param  {Function} fn  Optional function to compare\n   * @return {Boolean}      True if the heap was modified\n   */\n\n\n  Heap.prototype.remove = function (o, fn) {\n    if (fn === void 0) {\n      fn = Heap.defaultIsEqual;\n    }\n\n    if (this.length > 0) {\n      if (o === undefined) {\n        this.pop();\n        return true;\n      } else {\n        var idx = this.heapArray.findIndex(function (el) {\n          return fn(el, o);\n        });\n\n        if (idx >= 0) {\n          if (idx === 0) {\n            this.pop();\n          } else if (idx === this.length - 1) {\n            this.heapArray.pop();\n          } else {\n            this.heapArray.splice(idx, 1, this.heapArray.pop());\n\n            this._sortNodeUp(idx);\n\n            this._sortNodeDown(idx);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Pop the current peek value, and add the new item.\n   * @param  {any} element  Element to replace peek\n   * @return {any}         Old peek\n   */\n\n\n  Heap.prototype.replace = function (element) {\n    var peek = this.heapArray[0];\n    this.heapArray[0] = element;\n\n    this._sortNodeDown(0);\n\n    return peek;\n  };\n  /**\n   * Size of the heap\n   * @return {Number}\n   */\n\n\n  Heap.prototype.size = function () {\n    return this.length;\n  };\n  /**\n   * Return the top (highest value) N elements of the heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}    Array of length <= N.\n   */\n\n\n  Heap.prototype.top = function (n) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    if (this.heapArray.length === 0 || n <= 0) {\n      // Nothing to do\n      return [];\n    } else if (this.heapArray.length === 1 || n === 1) {\n      // Just the peek\n      return [this.heapArray[0]];\n    } else if (n >= this.heapArray.length) {\n      // The whole peek\n      return this.heapArray.slice(0);\n    } else {\n      // Some elements\n      var result = this._topN_push(n);\n\n      return result;\n    }\n  };\n  /**\n   * Clone the heap's internal array\n   * @return {Array}\n   */\n\n\n  Heap.prototype.toArray = function () {\n    return this.heapArray.slice(0);\n  };\n  /**\n   * String output, call to Array.prototype.toString()\n   * @return {String}\n   */\n\n\n  Heap.prototype.toString = function () {\n    return this.heapArray.toString();\n  };\n  /**\n   * Get the element at the given index.\n   * @param  {Number} i Index to get\n   * @return {any}       Element at that index\n   */\n\n\n  Heap.prototype.get = function (i) {\n    return this.heapArray[i];\n  };\n  /**\n   * Get the elements of these node's children\n   * @param  {Number} idx Node index\n   * @return {Array(any)}  Children elements\n   */\n\n\n  Heap.prototype.getChildrenOf = function (idx) {\n    var _this = this;\n\n    return Heap.getChildrenIndexOf(idx).map(function (i) {\n      return _this.heapArray[i];\n    }).filter(function (e) {\n      return e !== undefined;\n    });\n  };\n  /**\n   * Get the element of this node's parent\n   * @param  {Number} idx Node index\n   * @return {any}     Parent element\n   */\n\n\n  Heap.prototype.getParentOf = function (idx) {\n    var pi = Heap.getParentIndexOf(idx);\n    return this.heapArray[pi];\n  };\n  /**\n   * Iterator interface\n   */\n\n\n  Heap.prototype[Symbol.iterator] = function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!this.length) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , this.pop()];\n\n        case 1:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 0];\n\n        case 2:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n  /**\n   * Returns an iterator. To comply with Java interface.\n   */\n\n\n  Heap.prototype.iterator = function () {\n    return this;\n  };\n  /**\n   * Limit heap size if needed\n   */\n\n\n  Heap.prototype._applyLimit = function () {\n    if (this._limit && this._limit < this.heapArray.length) {\n      var rm = this.heapArray.length - this._limit; // It's much faster than splice\n\n      while (rm) {\n        this.heapArray.pop();\n        --rm;\n      }\n    }\n  };\n  /**\n   * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n\n\n  Heap.prototype._bottomN_push = function (n) {\n    // Use an inverted heap\n    var bottomHeap = new Heap(this.compare);\n    bottomHeap.limit = n;\n    bottomHeap.init(this.heapArray.slice(-n));\n    var startAt = this.heapArray.length - 1 - n;\n    var parentStartAt = Heap.getParentIndexOf(startAt);\n    var indices = [];\n\n    for (var i = startAt; i > parentStartAt; --i) {\n      indices.push(i);\n    }\n\n    var arr = this.heapArray;\n\n    while (indices.length) {\n      var i = indices.shift();\n\n      if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n        bottomHeap.replace(arr[i]);\n\n        if (i % 2) {\n          indices.push(Heap.getParentIndexOf(i));\n        }\n      }\n    }\n\n    return bottomHeap.toArray();\n  };\n  /**\n   * Move a node to a new index, switching places\n   * @param  {Number} j First node index\n   * @param  {Number} k Another node index\n   */\n\n\n  Heap.prototype._moveNode = function (j, k) {\n    var _a;\n\n    _a = [this.heapArray[k], this.heapArray[j]], this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n  };\n  /**\n   * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n   * @param  {Number} i Index of the node\n   */\n\n\n  Heap.prototype._sortNodeDown = function (i) {\n    var _this = this;\n\n    var moveIt = i < this.heapArray.length - 1;\n    var self = this.heapArray[i];\n\n    var getPotentialParent = function (best, j) {\n      if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n        best = j;\n      }\n\n      return best;\n    };\n\n    while (moveIt) {\n      var childrenIdx = Heap.getChildrenIndexOf(i);\n      var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n      var bestChild = this.heapArray[bestChildIndex];\n\n      if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n        this._moveNode(i, bestChildIndex);\n\n        i = bestChildIndex;\n      } else {\n        moveIt = false;\n      }\n    }\n  };\n  /**\n   * Move a node up the tree (to the root) to find a place where the heap is sorted.\n   * @param  {Number} i Index of the node\n   */\n\n\n  Heap.prototype._sortNodeUp = function (i) {\n    var moveIt = i > 0;\n\n    while (moveIt) {\n      var pi = Heap.getParentIndexOf(i);\n\n      if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n        this._moveNode(i, pi);\n\n        i = pi;\n      } else {\n        moveIt = false;\n      }\n    }\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: push.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n\n\n  Heap.prototype._topN_push = function (n) {\n    // Use an inverted heap\n    var topHeap = new Heap(this._invertedCompare);\n    topHeap.limit = n;\n    var indices = [0];\n    var arr = this.heapArray;\n\n    while (indices.length) {\n      var i = indices.shift();\n\n      if (i < arr.length) {\n        if (topHeap.length < n) {\n          topHeap.push(arr[i]);\n          indices.push.apply(indices, Heap.getChildrenIndexOf(i));\n        } else if (this.compare(arr[i], topHeap.peek()) < 0) {\n          topHeap.replace(arr[i]);\n          indices.push.apply(indices, Heap.getChildrenIndexOf(i));\n        }\n      }\n    }\n\n    return topHeap.toArray();\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: init + push.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n\n\n  Heap.prototype._topN_fill = function (n) {\n    // Use an inverted heap\n    var heapArray = this.heapArray;\n    var topHeap = new Heap(this._invertedCompare);\n    topHeap.limit = n;\n    topHeap.init(heapArray.slice(0, n));\n    var branch = Heap.getParentIndexOf(n - 1) + 1;\n    var indices = [];\n\n    for (var i = branch; i < n; ++i) {\n      indices.push.apply(indices, Heap.getChildrenIndexOf(i).filter(function (l) {\n        return l < heapArray.length;\n      }));\n    }\n\n    if ((n - 1) % 2) {\n      indices.push(n);\n    }\n\n    while (indices.length) {\n      var i = indices.shift();\n\n      if (i < heapArray.length) {\n        if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n          topHeap.replace(heapArray[i]);\n          indices.push.apply(indices, Heap.getChildrenIndexOf(i));\n        }\n      }\n    }\n\n    return topHeap.toArray();\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n\n\n  Heap.prototype._topN_heap = function (n) {\n    var topHeap = this.clone();\n    var result = [];\n\n    for (var i = 0; i < n; ++i) {\n      result.push(topHeap.pop());\n    }\n\n    return result;\n  };\n  /**\n   * Return index of the top element\n   * @param list\n   */\n\n\n  Heap.prototype._topIdxOf = function (list) {\n    if (!list.length) {\n      return -1;\n    }\n\n    var idx = 0;\n    var top = list[idx];\n\n    for (var i = 1; i < list.length; ++i) {\n      var comp = this.compare(list[i], top);\n\n      if (comp < 0) {\n        idx = i;\n        top = list[i];\n      }\n    }\n\n    return idx;\n  };\n  /**\n   * Return the top element\n   * @param list\n   */\n\n\n  Heap.prototype._topOf = function () {\n    var list = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      list[_i] = arguments[_i];\n    }\n\n    var heap = new Heap(this.compare);\n    heap.init(list);\n    return heap.peek();\n  };\n\n  return Heap;\n}();\n\nexport default Heap;\nexport { Heap };","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/Pathfinder_Simulator/node_modules/heap-js/dist/heap-js.es5.js"],"names":["__generator","undefined","thisArg","body","_","label","sent","t","trys","ops","f","y","g","next","verb","Symbol","iterator","n","v","step","op","TypeError","call","done","value","pop","length","push","e","Heap","compare","_this","minComparator","heapArray","_limit","offer","add","element","peek","poll","_invertedCompare","a","b","getChildrenIndexOf","idx","getParentIndexOf","whichChildren","Math","floor","getSiblingIndexOf","maxComparator","minComparatorNumber","maxComparatorNumber","defaultIsEqual","print","heap","deep","i","pi","log2","repeat","str","times","out","node","lines","maxLines","maxLength","nodeText","String","get","map","line","pow","el","half","ceil","join","heapify","arr","init","heappop","heapArr","heappush","item","heappushpop","pushpop","heapreplace","replace","heaptop","top","heapbottom","bottom","prototype","_sortNodeUp","_applyLimit","addAll","elements","_a","apply","l","slice","result","_bottomN_push","check","find","j","getChildrenOf","ch","clear","clone","cloned","comparator","toArray","contains","o","fn","findIndex","array","_sortNodeDown","isEmpty","leafs","Object","defineProperty","enumerable","configurable","set","_l","last","_i","arguments","remove","splice","size","_topN_push","toString","filter","getParentOf","rm","bottomHeap","limit","startAt","parentStartAt","indices","shift","_moveNode","k","moveIt","self","getPotentialParent","best","childrenIdx","bestChildIndex","reduce","bestChild","topHeap","_topN_fill","branch","_topN_heap","_topIdxOf","list","comp","_topOf"],"mappings":"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","sourcesContent":["var __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n/**\n * Heap\n * @type {Class}\n */\nvar Heap = /** @class */ (function () {\n    /**\n     * Heap instance constructor.\n     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n     */\n    function Heap(compare) {\n        var _this = this;\n        if (compare === void 0) { compare = Heap.minComparator; }\n        this.compare = compare;\n        this.heapArray = [];\n        this._limit = 0;\n        /**\n         * Alias of add\n         */\n        this.offer = this.add;\n        /**\n         * Alias of peek\n         */\n        this.element = this.peek;\n        /**\n         * Alias of pop\n         */\n        this.poll = this.pop;\n        /**\n         * Returns the inverse to the comparison function.\n         * @return {Function}\n         */\n        this._invertedCompare = function (a, b) {\n            return -1 * _this.compare(a, b);\n        };\n    }\n    /*\n              Static methods\n     */\n    /**\n     * Gets children indices for given index.\n     * @param  {Number} idx     Parent index\n     * @return {Array(Number)}  Array of children indices\n     */\n    Heap.getChildrenIndexOf = function (idx) {\n        return [idx * 2 + 1, idx * 2 + 2];\n    };\n    /**\n     * Gets parent index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Parent index, -1 if idx is 0\n     */\n    Heap.getParentIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : 2;\n        return Math.floor((idx - whichChildren) / 2);\n    };\n    /**\n     * Gets sibling index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Sibling index, -1 if idx is 0\n     */\n    Heap.getSiblingIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : -1;\n        return idx + whichChildren;\n    };\n    /**\n     * Min heap comparison function, default.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparator = function (a, b) {\n        if (a > b) {\n            return 1;\n        }\n        else if (a < b) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Max heap comparison function.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparator = function (a, b) {\n        if (b > a) {\n            return 1;\n        }\n        else if (b < a) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Min number heap comparison function, default.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparatorNumber = function (a, b) {\n        return a - b;\n    };\n    /**\n     * Max number heap comparison function.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparatorNumber = function (a, b) {\n        return b - a;\n    };\n    /**\n     * Default equality function.\n     * @param  {any} a    First element\n     * @param  {any} b    Second element\n     * @return {Boolean}  True if equal, false otherwise\n     */\n    Heap.defaultIsEqual = function (a, b) {\n        return a === b;\n    };\n    /**\n     * Prints a heap.\n     * @param  {Heap} heap Heap to be printed\n     * @returns {String}\n     */\n    Heap.print = function (heap) {\n        function deep(i) {\n            var pi = Heap.getParentIndexOf(i);\n            return Math.floor(Math.log2(pi + 1));\n        }\n        function repeat(str, times) {\n            var out = '';\n            for (; times > 0; --times) {\n                out += str;\n            }\n            return out;\n        }\n        var node = 0;\n        var lines = [];\n        var maxLines = deep(heap.length - 1) + 2;\n        var maxLength = 0;\n        while (node < heap.length) {\n            var i = deep(node) + 1;\n            if (node === 0) {\n                i = 0;\n            }\n            // Text representation\n            var nodeText = String(heap.get(node));\n            if (nodeText.length > maxLength) {\n                maxLength = nodeText.length;\n            }\n            // Add to line\n            lines[i] = lines[i] || [];\n            lines[i].push(nodeText);\n            node += 1;\n        }\n        return lines\n            .map(function (line, i) {\n            var times = Math.pow(2, maxLines - i) - 1;\n            return (repeat(' ', Math.floor(times / 2) * maxLength) +\n                line\n                    .map(function (el) {\n                    // centered\n                    var half = (maxLength - el.length) / 2;\n                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n                })\n                    .join(repeat(' ', times * maxLength)));\n        })\n            .join('\\n');\n    };\n    /*\n              Python style\n     */\n    /**\n     * Converts an array into an array-heap\n     * @param  {Array}    arr      Array to be modified\n     * @param  {Function} compare  Optional compare function\n     * @return {Heap}              For convenience, it returns a Heap instance\n     */\n    Heap.heapify = function (arr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = arr;\n        heap.init();\n        return heap;\n    };\n    /**\n     * Extract the peek of an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappop = function (heapArr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pop();\n    };\n    /**\n     * Pushes a item into an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     */\n    Heap.heappush = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        heap.push(item);\n    };\n    /**\n     * Push followed by pop, faster\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappushpop = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pushpop(item);\n    };\n    /**\n     * Replace peek with item\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item as replacement\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heapreplace = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.replace(item);\n    };\n    /**\n     * Return the `n` most valuable elements\n     * @param  {Array}    heapArr  Array, should be a heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heaptop = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements\n     * @param  {Array}    heapArr  Array, should be a heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heapbottom = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.bottom(n);\n    };\n    /*\n              Instance methods\n     */\n    /**\n     * Adds an element to the heap. Aliases: `offer`.\n     * Same as: push(element)\n     * @param {any} element Element to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.add = function (element) {\n        this._sortNodeUp(this.heapArray.push(element) - 1);\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Adds an array of elements to the heap.\n     * Similar as: push(element, element, ...).\n     * @param {Array} elements Elements to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.addAll = function (elements) {\n        var _a;\n        var i = this.length;\n        (_a = this.heapArray).push.apply(_a, elements);\n        for (var l = this.length; i < l; ++i) {\n            this._sortNodeUp(i);\n        }\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype.bottom = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole heap\n            return this.heapArray.slice(0);\n        }\n        else {\n            // Some elements\n            var result = this._bottomN_push(n);\n            return result;\n        }\n    };\n    /**\n     * Check if the heap is sorted, useful for testing purposes.\n     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n     */\n    Heap.prototype.check = function () {\n        var _this = this;\n        return this.heapArray.find(function (el, j, arr) { return !!_this.getChildrenOf(j).find(function (ch) { return _this.compare(el, ch) > 0; }); });\n    };\n    /**\n     * Remove all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.heapArray = [];\n    };\n    /**\n     * Clone this heap\n     * @return {Heap}\n     */\n    Heap.prototype.clone = function () {\n        var cloned = new Heap(this.comparator());\n        cloned.heapArray = this.toArray();\n        cloned._limit = this._limit;\n        return cloned;\n    };\n    /**\n     * Returns the comparison function.\n     * @return {Function}\n     */\n    Heap.prototype.comparator = function () {\n        return this.compare;\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * @param  {any}      o   Element to be found\n     * @param  {Function} fn  Optional comparison function, receives (element, needle)\n     * @return {Boolean}\n     */\n    Heap.prototype.contains = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        return this.heapArray.findIndex(function (el) { return fn(el, o); }) >= 0;\n    };\n    /**\n     * Initialise a heap, sorting nodes\n     * @param  {Array} array Optional initial state array\n     */\n    Heap.prototype.init = function (array) {\n        if (array) {\n            this.heapArray = array.slice(0);\n        }\n        for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n            this._sortNodeDown(i);\n        }\n        this._applyLimit();\n    };\n    /**\n     * Test if the heap has no elements.\n     * @return {Boolean} True if no elements on the heap\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    /**\n     * Get the leafs of the tree (no children nodes)\n     */\n    Heap.prototype.leafs = function () {\n        if (this.heapArray.length === 0) {\n            return [];\n        }\n        var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n        return this.heapArray.slice(pi + 1);\n    };\n    Object.defineProperty(Heap.prototype, \"length\", {\n        /**\n         * Length of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this.heapArray.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Heap.prototype, \"limit\", {\n        /**\n         * Get length limit of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * Set length limit of the heap.\n         * @return {Number}\n         */\n        set: function (_l) {\n            this._limit = _l;\n            this._applyLimit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Top node. Aliases: `element`.\n     * Same as: `top(1)[0]`\n     * @return {any} Top node\n     */\n    Heap.prototype.peek = function () {\n        return this.heapArray[0];\n    };\n    /**\n     * Extract the top node (root). Aliases: `poll`.\n     * @return {any} Extracted top node, undefined if empty\n     */\n    Heap.prototype.pop = function () {\n        var last = this.heapArray.pop();\n        if (this.length > 0 && last !== undefined) {\n            return this.replace(last);\n        }\n        return last;\n    };\n    /**\n     * Pushes element(s) to the heap.\n     * @param  {...any} elements Elements to insert\n     * @return {Boolean} True if elements are present\n     */\n    Heap.prototype.push = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        if (elements.length < 1) {\n            return false;\n        }\n        else if (elements.length === 1) {\n            return this.add(elements[0]);\n        }\n        else {\n            return this.addAll(elements);\n        }\n    };\n    /**\n     * Same as push & pop in sequence, but faster\n     * @param  {any} element Element to insert\n     * @return {any}  Extracted top node\n     */\n    Heap.prototype.pushpop = function (element) {\n        var _a;\n        if (this.compare(this.heapArray[0], element) < 0) {\n            _a = [this.heapArray[0], element], element = _a[0], this.heapArray[0] = _a[1];\n            this._sortNodeDown(0);\n        }\n        return element;\n    };\n    /**\n     * Remove an element from the heap.\n     * @param  {any}   o      Element to be found\n     * @param  {Function} fn  Optional function to compare\n     * @return {Boolean}      True if the heap was modified\n     */\n    Heap.prototype.remove = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        if (this.length > 0) {\n            if (o === undefined) {\n                this.pop();\n                return true;\n            }\n            else {\n                var idx = this.heapArray.findIndex(function (el) { return fn(el, o); });\n                if (idx >= 0) {\n                    if (idx === 0) {\n                        this.pop();\n                    }\n                    else if (idx === this.length - 1) {\n                        this.heapArray.pop();\n                    }\n                    else {\n                        this.heapArray.splice(idx, 1, this.heapArray.pop());\n                        this._sortNodeUp(idx);\n                        this._sortNodeDown(idx);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * Pop the current peek value, and add the new item.\n     * @param  {any} element  Element to replace peek\n     * @return {any}         Old peek\n     */\n    Heap.prototype.replace = function (element) {\n        var peek = this.heapArray[0];\n        this.heapArray[0] = element;\n        this._sortNodeDown(0);\n        return peek;\n    };\n    /**\n     * Size of the heap\n     * @return {Number}\n     */\n    Heap.prototype.size = function () {\n        return this.length;\n    };\n    /**\n     * Return the top (highest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}    Array of length <= N.\n     */\n    Heap.prototype.top = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1 || n === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole peek\n            return this.heapArray.slice(0);\n        }\n        else {\n            // Some elements\n            var result = this._topN_push(n);\n            return result;\n        }\n    };\n    /**\n     * Clone the heap's internal array\n     * @return {Array}\n     */\n    Heap.prototype.toArray = function () {\n        return this.heapArray.slice(0);\n    };\n    /**\n     * String output, call to Array.prototype.toString()\n     * @return {String}\n     */\n    Heap.prototype.toString = function () {\n        return this.heapArray.toString();\n    };\n    /**\n     * Get the element at the given index.\n     * @param  {Number} i Index to get\n     * @return {any}       Element at that index\n     */\n    Heap.prototype.get = function (i) {\n        return this.heapArray[i];\n    };\n    /**\n     * Get the elements of these node's children\n     * @param  {Number} idx Node index\n     * @return {Array(any)}  Children elements\n     */\n    Heap.prototype.getChildrenOf = function (idx) {\n        var _this = this;\n        return Heap.getChildrenIndexOf(idx)\n            .map(function (i) { return _this.heapArray[i]; })\n            .filter(function (e) { return e !== undefined; });\n    };\n    /**\n     * Get the element of this node's parent\n     * @param  {Number} idx Node index\n     * @return {any}     Parent element\n     */\n    Heap.prototype.getParentOf = function (idx) {\n        var pi = Heap.getParentIndexOf(idx);\n        return this.heapArray[pi];\n    };\n    /**\n     * Iterator interface\n     */\n    Heap.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.length) return [3 /*break*/, 2];\n                    return [4 /*yield*/, this.pop()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Returns an iterator. To comply with Java interface.\n     */\n    Heap.prototype.iterator = function () {\n        return this;\n    };\n    /**\n     * Limit heap size if needed\n     */\n    Heap.prototype._applyLimit = function () {\n        if (this._limit && this._limit < this.heapArray.length) {\n            var rm = this.heapArray.length - this._limit;\n            // It's much faster than splice\n            while (rm) {\n                this.heapArray.pop();\n                --rm;\n            }\n        }\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._bottomN_push = function (n) {\n        // Use an inverted heap\n        var bottomHeap = new Heap(this.compare);\n        bottomHeap.limit = n;\n        bottomHeap.init(this.heapArray.slice(-n));\n        var startAt = this.heapArray.length - 1 - n;\n        var parentStartAt = Heap.getParentIndexOf(startAt);\n        var indices = [];\n        for (var i = startAt; i > parentStartAt; --i) {\n            indices.push(i);\n        }\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n                bottomHeap.replace(arr[i]);\n                if (i % 2) {\n                    indices.push(Heap.getParentIndexOf(i));\n                }\n            }\n        }\n        return bottomHeap.toArray();\n    };\n    /**\n     * Move a node to a new index, switching places\n     * @param  {Number} j First node index\n     * @param  {Number} k Another node index\n     */\n    Heap.prototype._moveNode = function (j, k) {\n        var _a;\n        _a = [this.heapArray[k], this.heapArray[j]], this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n    };\n    /**\n     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeDown = function (i) {\n        var _this = this;\n        var moveIt = i < this.heapArray.length - 1;\n        var self = this.heapArray[i];\n        var getPotentialParent = function (best, j) {\n            if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n                best = j;\n            }\n            return best;\n        };\n        while (moveIt) {\n            var childrenIdx = Heap.getChildrenIndexOf(i);\n            var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n            var bestChild = this.heapArray[bestChildIndex];\n            if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n                this._moveNode(i, bestChildIndex);\n                i = bestChildIndex;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Move a node up the tree (to the root) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeUp = function (i) {\n        var moveIt = i > 0;\n        while (moveIt) {\n            var pi = Heap.getParentIndexOf(i);\n            if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n                this._moveNode(i, pi);\n                i = pi;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_push = function (n) {\n        // Use an inverted heap\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        var indices = [0];\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < arr.length) {\n                if (topHeap.length < n) {\n                    topHeap.push(arr[i]);\n                    indices.push.apply(indices, Heap.getChildrenIndexOf(i));\n                }\n                else if (this.compare(arr[i], topHeap.peek()) < 0) {\n                    topHeap.replace(arr[i]);\n                    indices.push.apply(indices, Heap.getChildrenIndexOf(i));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: init + push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_fill = function (n) {\n        // Use an inverted heap\n        var heapArray = this.heapArray;\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        topHeap.init(heapArray.slice(0, n));\n        var branch = Heap.getParentIndexOf(n - 1) + 1;\n        var indices = [];\n        for (var i = branch; i < n; ++i) {\n            indices.push.apply(indices, Heap.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; }));\n        }\n        if ((n - 1) % 2) {\n            indices.push(n);\n        }\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < heapArray.length) {\n                if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n                    topHeap.replace(heapArray[i]);\n                    indices.push.apply(indices, Heap.getChildrenIndexOf(i));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_heap = function (n) {\n        var topHeap = this.clone();\n        var result = [];\n        for (var i = 0; i < n; ++i) {\n            result.push(topHeap.pop());\n        }\n        return result;\n    };\n    /**\n     * Return index of the top element\n     * @param list\n     */\n    Heap.prototype._topIdxOf = function (list) {\n        if (!list.length) {\n            return -1;\n        }\n        var idx = 0;\n        var top = list[idx];\n        for (var i = 1; i < list.length; ++i) {\n            var comp = this.compare(list[i], top);\n            if (comp < 0) {\n                idx = i;\n                top = list[i];\n            }\n        }\n        return idx;\n    };\n    /**\n     * Return the top element\n     * @param list\n     */\n    Heap.prototype._topOf = function () {\n        var list = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            list[_i] = arguments[_i];\n        }\n        var heap = new Heap(this.compare);\n        heap.init(list);\n        return heap.peek();\n    };\n    return Heap;\n}());\n\nexport default Heap;\nexport { Heap };\n"]},"metadata":{},"sourceType":"module"}