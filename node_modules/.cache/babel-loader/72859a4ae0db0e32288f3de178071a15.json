{"ast":null,"code":"// Custom heap implementation\nexport default class MinHeap {\n  constructor() {\n    /* Initialing the array heap and adding a dummy element at index 0 */\n    this.heap = [null];\n  }\n\n  getMin() {\n    /* Accessing the min element at index 1 in the heap array */\n    return this.heap[1];\n  }\n\n  insert(node) {\n    /* Inserting the new node at the end of the heap array */\n    this.heap.push(node);\n    /* Finding the correct position for the new node */\n\n    if (this.heap.length > 1) {\n      let current = this.heap.length - 1;\n      /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/\n\n      while (current > 1 && this.heap[Math.floor(current / 2)] > this.heap[current]) {\n        /* Swapping the two nodes by using the ES6 destructuring syntax*/\n        [this.heap[Math.floor(current / 2)], this.heap[current]] = [this.heap[current], this.heap[Math.floor(current / 2)]];\n        current = Math.floor(current / 2);\n      }\n    }\n  }\n\n  remove() {\n    /* Smallest element is at the index 1 in the heap array */\n    let smallest = this.heap[1];\n    /* When there are more than two elements in the array, we put the right most element at the first position\n          and start comparing nodes with the child nodes\n      */\n\n    if (this.heap.length > 2) {\n      this.heap[1] = this.heap[this.heap.length - 1];\n      this.heap.splice(this.heap.length - 1);\n\n      if (this.heap.length === 3) {\n        if (this.heap[1] > this.heap[2]) {\n          [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]];\n        }\n\n        return smallest;\n      }\n\n      let current = 1;\n      let leftChildIndex = current * 2;\n      let rightChildIndex = current * 2 + 1;\n\n      while (this.heap[leftChildIndex] && this.heap[rightChildIndex] && (this.heap[current] < this.heap[leftChildIndex] || this.heap[current] < this.heap[rightChildIndex])) {\n        if (this.heap[leftChildIndex] < this.heap[rightChildIndex]) {\n          [this.heap[current], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[current]];\n          current = leftChildIndex;\n        } else {\n          [this.heap[current], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[current]];\n          current = rightChildIndex;\n        }\n\n        leftChildIndex = current * 2;\n        rightChildIndex = current * 2 + 1;\n      }\n    } else if (this.heap.length === 2) {\n      /* If there are only two elements in the array, we directly splice out the first element */\n      this.heap.splice(1, 1);\n    } else {\n      return null;\n    }\n\n    return smallest;\n  }\n\n}","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/structures/heap.js"],"names":["MinHeap","constructor","heap","getMin","insert","node","push","length","current","Math","floor","remove","smallest","splice","leftChildIndex","rightChildIndex"],"mappings":"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","sourcesContent":["// Custom heap implementation\n\nexport default class MinHeap {\n  constructor() {\n    /* Initialing the array heap and adding a dummy element at index 0 */\n    this.heap = [null];\n  }\n\n  getMin() {\n    /* Accessing the min element at index 1 in the heap array */\n    return this.heap[1];\n  }\n\n  insert(node) {\n    /* Inserting the new node at the end of the heap array */\n    this.heap.push(node);\n\n    /* Finding the correct position for the new node */\n\n    if (this.heap.length > 1) {\n      let current = this.heap.length - 1;\n\n      /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/\n      while (\n        current > 1 &&\n        this.heap[Math.floor(current / 2)] > this.heap[current]\n      ) {\n        /* Swapping the two nodes by using the ES6 destructuring syntax*/\n        [this.heap[Math.floor(current / 2)], this.heap[current]] = [\n          this.heap[current],\n          this.heap[Math.floor(current / 2)],\n        ];\n        current = Math.floor(current / 2);\n      }\n    }\n  }\n\n  remove() {\n    /* Smallest element is at the index 1 in the heap array */\n    let smallest = this.heap[1];\n\n    /* When there are more than two elements in the array, we put the right most element at the first position\n          and start comparing nodes with the child nodes\n      */\n    if (this.heap.length > 2) {\n      this.heap[1] = this.heap[this.heap.length - 1];\n      this.heap.splice(this.heap.length - 1);\n\n      if (this.heap.length === 3) {\n        if (this.heap[1] > this.heap[2]) {\n          [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]];\n        }\n        return smallest;\n      }\n\n      let current = 1;\n      let leftChildIndex = current * 2;\n      let rightChildIndex = current * 2 + 1;\n\n      while (\n        this.heap[leftChildIndex] &&\n        this.heap[rightChildIndex] &&\n        (this.heap[current] < this.heap[leftChildIndex] ||\n          this.heap[current] < this.heap[rightChildIndex])\n      ) {\n        if (this.heap[leftChildIndex] < this.heap[rightChildIndex]) {\n          [this.heap[current], this.heap[leftChildIndex]] = [\n            this.heap[leftChildIndex],\n            this.heap[current],\n          ];\n          current = leftChildIndex;\n        } else {\n          [this.heap[current], this.heap[rightChildIndex]] = [\n            this.heap[rightChildIndex],\n            this.heap[current],\n          ];\n          current = rightChildIndex;\n        }\n\n        leftChildIndex = current * 2;\n        rightChildIndex = current * 2 + 1;\n      }\n    } else if (this.heap.length === 2) {\n      /* If there are only two elements in the array, we directly splice out the first element */\n      this.heap.splice(1, 1);\n    } else {\n      return null;\n    }\n\n    return smallest;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}