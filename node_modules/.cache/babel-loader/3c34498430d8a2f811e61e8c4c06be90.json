{"ast":null,"code":"// Custom heap implementation\nexport default class MinHeap {\n  constructor() {\n    /* Initialing the array heap and adding a dummy element at index 0 */\n    this.heap = [null];\n  }\n\n  peek() {\n    /* Accessing the min element at index 1 in the heap array */\n    return this.heap[0];\n  }\n\n  getLength() {\n    return this.heap.length;\n  }\n\n  insert(node) {\n    /* Inserting the new node at the end of the heap array */\n    this.heap.push(node);\n    /* Finding the correct position for the new node */\n\n    if (this.heap.length > 1) {\n      let current = this.heap.length - 1;\n      /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/\n\n      while (current > 1 && this.heap[Math.floor(current / 2)].f > this.heap[current].f) {\n        /* Swapping the two nodes by using the ES6 destructuring syntax*/\n        [this.heap[Math.floor(current / 2)], this.heap[current]] = [this.heap[current], this.heap[Math.floor(current / 2)]];\n        current = Math.floor(current / 2);\n      }\n    }\n  }\n\n  remove() {\n    /* Smallest element is at the index 1 in the heap array */\n    let smallest = this.heap[1];\n    /* When there are more than two elements in the array, we put the right most element at the first position\n          and start comparing nodes with the child nodes\n      */\n\n    if (this.heap.length > 2) {\n      this.heap[1] = this.heap[this.heap.length - 1];\n      this.heap.splice(this.heap.length - 1);\n\n      if (this.heap.length === 3) {\n        if (this.heap[1].f > this.heap[2].f) {\n          [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]];\n        }\n\n        return smallest;\n      }\n\n      let current = 1;\n      let leftChildIndex = current * 2;\n      let rightChildIndex = current * 2 + 1;\n\n      while (this.heap[leftChildIndex] && this.heap[rightChildIndex] && (this.heap[current].f < this.heap[leftChildIndex].f || this.heap[current].f < this.heap[rightChildIndex].f)) {\n        if (this.heap[leftChildIndex].f < this.heap[rightChildIndex].f) {\n          [this.heap[current], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[current]];\n          current = leftChildIndex;\n        } else {\n          [this.heap[current], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[current]];\n          current = rightChildIndex;\n        }\n\n        leftChildIndex = current * 2;\n        rightChildIndex = current * 2 + 1;\n      }\n    } else if (this.heap.length === 2) {\n      /* If there are only two elements in the array, we directly splice out the first element */\n      this.heap.splice(1, 1);\n    } else {\n      return null;\n    }\n\n    return smallest;\n  }\n\n}","map":{"version":3,"sources":["/Users/milanfatschel/Desktop/pathfinder_visualization/src/structures/heap.js"],"names":["MinHeap","constructor","heap","peek","getLength","length","insert","node","push","current","Math","floor","f","remove","smallest","splice","leftChildIndex","rightChildIndex"],"mappings":"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","sourcesContent":["// Custom heap implementation\n\nexport default class MinHeap {\n  constructor() {\n    /* Initialing the array heap and adding a dummy element at index 0 */\n    this.heap = [null];\n  }\n\n  peek() {\n    /* Accessing the min element at index 1 in the heap array */\n    return this.heap[0];\n  }\n\n  getLength() {\n    return this.heap.length;\n  }\n\n  insert(node) {\n    /* Inserting the new node at the end of the heap array */\n    this.heap.push(node);\n\n    /* Finding the correct position for the new node */\n\n    if (this.heap.length > 1) {\n      let current = this.heap.length - 1;\n\n      /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/\n      while (\n        current > 1 &&\n        this.heap[Math.floor(current / 2)].f > this.heap[current].f\n      ) {\n        /* Swapping the two nodes by using the ES6 destructuring syntax*/\n        [this.heap[Math.floor(current / 2)], this.heap[current]] = [\n          this.heap[current],\n          this.heap[Math.floor(current / 2)],\n        ];\n        current = Math.floor(current / 2);\n      }\n    }\n  }\n\n  remove() {\n    /* Smallest element is at the index 1 in the heap array */\n    let smallest = this.heap[1];\n\n    /* When there are more than two elements in the array, we put the right most element at the first position\n          and start comparing nodes with the child nodes\n      */\n    if (this.heap.length > 2) {\n      this.heap[1] = this.heap[this.heap.length - 1];\n      this.heap.splice(this.heap.length - 1);\n\n      if (this.heap.length === 3) {\n        if (this.heap[1].f > this.heap[2].f) {\n          [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]];\n        }\n        return smallest;\n      }\n\n      let current = 1;\n      let leftChildIndex = current * 2;\n      let rightChildIndex = current * 2 + 1;\n\n      while (\n        this.heap[leftChildIndex] &&\n        this.heap[rightChildIndex] &&\n        (this.heap[current].f < this.heap[leftChildIndex].f ||\n          this.heap[current].f < this.heap[rightChildIndex].f)\n      ) {\n        if (this.heap[leftChildIndex].f < this.heap[rightChildIndex].f) {\n          [this.heap[current], this.heap[leftChildIndex]] = [\n            this.heap[leftChildIndex],\n            this.heap[current],\n          ];\n          current = leftChildIndex;\n        } else {\n          [this.heap[current], this.heap[rightChildIndex]] = [\n            this.heap[rightChildIndex],\n            this.heap[current],\n          ];\n          current = rightChildIndex;\n        }\n\n        leftChildIndex = current * 2;\n        rightChildIndex = current * 2 + 1;\n      }\n    } else if (this.heap.length === 2) {\n      /* If there are only two elements in the array, we directly splice out the first element */\n      this.heap.splice(1, 1);\n    } else {\n      return null;\n    }\n\n    return smallest;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}